<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Minecraft JS - Filled World</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #000; }
        #menu-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.4); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 100;
        }
        #play-button {
            padding: 15px 50px; font-size: 24px; background: #5d9b44;
            color: white; border: 4px solid #3d6b2c; cursor: pointer;
            font-weight: bold; transition: 0.2s;
        }
        #play-button:hover { background: #82c45c; transform: scale(1.05); }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 15px; height: 15px;
            border: 2px solid white; transform: translate(-50%, -50%);
            pointer-events: none; z-index: 10; display: none;
        }
        #inventory {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: none; gap: 10px; background: rgba(0,0,0,0.8); padding: 10px;
            border-radius: 12px; border: 2px solid #555;
        }
        .slot {
            width: 60px; height: 60px; border: 3px solid #444; color: white;
            display: flex; justify-content: center; align-items: center; font-size: 10px;
        }
        .slot.active { border-color: #00ff00; background: rgba(0,255,0,0.1); }
    </style>
</head>
<body>

    <div id="menu-overlay">
        <h1 style="color: white; text-shadow: 3px 3px #000;">MINECRAFT CLEAR EDITION</h1>
        <button id="play-button">ИГРАТЬ</button>
    </div>

    <div id="crosshair"></div>
    <div id="inventory">
        <div id="slot1" class="slot active">ТРАВА</div>
        <div id="slot2" class="slot">ГРЯЗЬ</div>
        <div id="slot3" class="slot">КАМЕНЬ</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- ИНИЦИАЛИЗАЦИЯ ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 30, 100);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true }); 
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new PointerLockControls(camera, document.body);
        let isPlaying = false;

        const menu = document.getElementById('menu-overlay');
        const crosshair = document.getElementById('crosshair');
        const inventory = document.getElementById('inventory');

        document.getElementById('play-button').onclick = () => controls.lock();
        controls.addEventListener('lock', () => { isPlaying = true; menu.style.display = 'none'; crosshair.style.display = 'block'; inventory.style.display = 'flex'; });
        controls.addEventListener('unlock', () => { isPlaying = false; menu.style.display = 'flex'; crosshair.style.display = 'none'; inventory.style.display = 'none'; });

        // --- МАТЕРИАЛЫ И ГЕОМЕТРИЯ ---
        const WORLD_SIZE = 20; // Немного уменьшим для производительности при заполнении
        const REACH = 5;
        const blocks = new Map();

        const mats = {
            grass: new THREE.MeshLambertMaterial({ color: 0x82c45c }),
            dirt: new THREE.MeshLambertMaterial({ color: 0x795548 }),
            stone: new THREE.MeshLambertMaterial({ color: 0x808080 }),
            bedrock: new THREE.MeshLambertMaterial({ color: 0x222222 })
        };
        const boxGeo = new THREE.BoxGeometry(1, 1, 1);
        const edgesGeo = new THREE.EdgesGeometry(boxGeo);
        const lineMat = new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.1 });

        const getPosKey = (x, y, z) => `${Math.round(x)},${Math.round(y)},${Math.round(z)}`;

        function addBlock(x, y, z, type, unbreakable = false) {
            const key = getPosKey(x, y, z);
            if (blocks.has(key)) return;

            const mesh = new THREE.Mesh(boxGeo, mats[type]);
            mesh.position.set(Math.round(x), Math.round(y), Math.round(z));
            mesh.userData = { type, unbreakable };

            const lines = new THREE.LineSegments(edgesGeo, lineMat);
            lines.raycast = () => {}; 
            mesh.add(lines);

            scene.add(mesh);
            blocks.set(key, mesh);
        }

        // --- ИСПРАВЛЕННАЯ ГЕНЕРАЦИЯ (ЗАПОЛНЕНИЕ ПУСТОТЫ) ---
        const BEDROCK_Y = -5;
        for (let x = -WORLD_SIZE; x <= WORLD_SIZE; x++) {
            for (let z = -WORLD_SIZE; z <= WORLD_SIZE; z++) {
                // Вычисляем высоту поверхности
                const surfaceY = Math.floor(Math.sin(x / 10) * 2 + Math.cos(z / 10) * 2);
                
                // Ставим бедрок на самом дне
                addBlock(x, BEDROCK_Y, z, 'bedrock', true);
                
                // Заполняем пространство ОТ бедрока ДО поверхности
                for (let y = BEDROCK_Y + 1; y <= surfaceY; y++) {
                    let type = 'dirt';
                    if (y === surfaceY) type = 'grass';
                    else if (y < surfaceY - 2) type = 'stone'; // Глубже 2 блоков — камень
                    
                    addBlock(x, y, z, type);
                }
            }
        }

        // --- СВЕТ ---
        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
        sunLight.position.set(10, 20, 10);
        scene.add(sunLight);

        // --- УПРАВЛЕНИЕ ---
        let keys = {}, velocity = new THREE.Vector3();
        let currentType = 'grass';
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (['1','2','3'].includes(e.key)) {
                if (e.key === '1') currentType = 'grass';
                if (e.key === '2') currentType = 'dirt';
                if (e.key === '3') currentType = 'stone';
                document.querySelectorAll('.slot').forEach((s, i) => s.classList.toggle('active', i === (parseInt(e.key)-1)));
            }
        });
        document.addEventListener('keyup', (e) => keys[e.code] = false);

        function checkCollision(pos) {
            // Проверка коллизий в нескольких точках (ноги, тело, голова)
            const checkPoints = [
                { x: 0.25, y: -1.75, z: 0.25 }, { x: -0.25, y: -1.75, z: -0.25 },
                { x: 0.25, y: -1.75, z: -0.25 }, { x: -0.25, y: -1.75, z: 0.25 },
                { x: 0, y: -0.9, z: 0 }, 
                { x: 0.25, y: 0, z: 0.25 }, { x: -0.25, y: 0, z: -0.25 }
            ];
            for (let p of checkPoints) {
                if (blocks.has(getPosKey(pos.x + p.x, pos.y + p.y, pos.z + p.z))) return true;
            }
            return false;
        }

        const raycaster = new THREE.Raycaster();
        window.addEventListener('mousedown', (e) => {
            if (!controls.isLocked) return;
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(Array.from(blocks.values()));
            
            if (intersects.length > 0 && intersects[0].distance < REACH) {
                const obj = intersects[0].object;
                if (e.button === 0 && !obj.userData.unbreakable) {
                    scene.remove(obj);
                    blocks.delete(getPosKey(obj.position.x, obj.position.y, obj.position.z));
                } else if (e.button === 2) {
                    const p = obj.position.clone().add(intersects[0].face.normal);
                    
                    // Запрет на установку блока в себя
                    const pX = Math.round(p.x);
                    const pY = Math.round(p.y);
                    const pZ = Math.round(p.z);
                    const camX = Math.round(camera.position.x);
                    const camZ = Math.round(camera.position.z);
                    const camYHead = Math.round(camera.position.y);
                    const camYFeet = Math.round(camera.position.y - 1);

                    const isColliding = pX === camX && pZ === camZ && (pY === camYHead || pY === camYFeet);

                    if (!isColliding) {
                        addBlock(p.x, p.y, p.z, currentType);
                    }
                }
            }
        });
        window.oncontextmenu = (e) => e.preventDefault();

        // --- LOOP ---
        camera.position.set(0, 10, 0);
        let prevTime = performance.now();
        let menuRotation = 0;

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = Math.min((time - prevTime) / 1000, 0.05);

            if (!isPlaying) {
                menuRotation += 0.005;
                camera.position.set(Math.sin(menuRotation) * 20, 10, Math.cos(menuRotation) * 20);
                camera.lookAt(0, 0, 0);
            } else {
                const prev = camera.position.clone();
                
                // Физика прыжка и потолка
                velocity.y -= 25 * delta;
                camera.position.y += velocity.y * delta;

                if (checkCollision(camera.position)) {
                    if (velocity.y > 0) {
                        velocity.y = 0; // Ударились головой
                    } else {
                        velocity.y = 0; // Стоим на земле
                        if (keys['Space']) velocity.y = 9;
                    }
                    camera.position.y = prev.y;
                }

                // Горизонтальное движение
                const move = new THREE.Vector3();
                if (keys['KeyW']) move.z -= 1; if (keys['KeyS']) move.z += 1;
                if (keys['KeyA']) move.x -= 1; if (keys['KeyD']) move.x += 1;
                move.normalize().applyQuaternion(camera.quaternion).setY(0);

                camera.position.x += move.x * 8 * delta;
                if (checkCollision(camera.position)) camera.position.x = prev.x;
                camera.position.z += move.z * 8 * delta;
                if (checkCollision(camera.position)) camera.position.z = prev.z;
            }
            prevTime = time;
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>